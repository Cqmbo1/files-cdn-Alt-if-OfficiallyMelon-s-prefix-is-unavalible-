Anti-CamShake:

   //Find:

   .addCameraShake(

    // & wrap around with:

    if (!window.camshake) {
    }

        raw example;


        // replace:

        e.addCameraShake(P / 40);
                    
        // with:

        if (!window.camshake) {
        e.addCameraShake(P / 40);
        }



Anti-Knock:

    // Find first: 

    '.applyImpulse('


    // & wrap around with:

    'if (!window.antiknock) {
    }
    '


        raw example:


        // replace:

        L.applyImpulse(W)

        // with: 

        if (!window.antiknock) {
            L.applyImpulse(W)
        }




SecureEdge/Prevent Falloff:

// to find from non-modified js: search: ').preventFallOffEdge'

                        //''/

                        //' to define States and Bodies:

                        // const physicsBody = >>U<<.ents.getPhysicsBody(>>>O<<<);
                        // const moveState = >>U<<.ents.getMoveState(>>>O<<<);

                        // get vars from: onAdd: function(>>Y<<, P) {}  & for (const P of >>>X<<<) 
                        // 1st var: '>><<'; 2nd: '>>><<<'

                        //' to find vars for toggle preventfalloff/secureEdge: 

                        //1st var: '<<>>'

                    //      if (!window.preventfalloff) {
                    //      if (physicsBody.preventFallOffEdge && !<<P>>._preventFallOffLastTick) {
                    //          (0, s.ac)();
                    //      }
                    //
                    //      physicsBody.preventFallOffEdge = moveState.crouching;
                    //        <<P>>._preventFallOffLastTick = moveState.crouching;
                    //    } else {
                    //        physicsBody.preventFallOffEdge = true;
                    //        <<P>>._preventFallOffLastTick = true;
                    //    }
                    
                    // get vars from (const <<P>> of X)

                    raw example:
                    
                    replace:

                        Y.ents.getPhysicsBody(X).preventFallOffEdge && !P._preventFallOffLastTick && (0,
                        q.Qb)(),
                        Y.ents.getPhysicsBody(X).preventFallOffEdge = Y.ents.getMoveState(X).crouching,
                        P._preventFallOffLastTick = Y.ents.getMoveState(X).crouching

                    with:

                        const physicsBody = Y.ents.getPhysicsBody(X);
                        const moveState = Y.ents.getMoveState(X);

                        if (!window.preventfalloff) {
                            if (physicsBody.preventFallOffEdge && !P._preventFallOffLastTick) {
                                (0, s.ac)();
                            }
        
                            physicsBody.preventFallOffEdge = moveState.crouching;
                            P._preventFallOffLastTick = moveState.crouching;
                        } else {
                            physicsBody.preventFallOffEdge = true;
                            P._preventFallOffLastTick = true;
                        }

Reach:

    // To find reach data go to first: tryHitEntity() { 

        find var from const (var)

        eg. P from: "const P" in:

            tryHitEntity() {
                var Y;
                const >>P<< = null !== (Y = this.noa.actionDirection) && void 0 !== Y ? Y : this.noa.camera.getDirection()
                  , {hitResult: X, hitEId: q, distanceTravelled: u, globalHitPosition: s, hitNormal: e, meshNodeHit: O} = this.pickActionHelper.doPickAction(P, 3);
                return X === S.c.HIT_ENTITY ? {
                    pickDir: P,
                    hitEId: q,
                    meshNodeHit: O
                } : {
                    pickDir: P,
                    hitEId: null,
                    meshNodeHit: null
                }
            }

        then at (var, 3);  :

        add " * (window.reach || 1)" to 3 to form:

        (var, 3 * (window.reach || 1));

        raw example:

        before:

            tryHitEntity() {
                    var Y;
                    const P = null !== (Y = this.noa.actionDirection) && void 0 !== Y ? Y : this.noa.camera.getDirection()
                    , {hitResult: X, hitEId: q, distanceTravelled: u, globalHitPosition: s, hitNormal: e, meshNodeHit: O} = this.pickActionHelper.doPickAction(P, 3);
                    return X === S.c.HIT_ENTITY ? {
                        pickDir: P,
                        hitEId: q,
                        meshNodeHit: O
                    } : {
                        pickDir: P,
                        hitEId: null,
                        meshNodeHit: null
                    }
                }

        to:

            tryHitEntity() {
                    var Y;
                    const P = null !== (Y = this.noa.actionDirection) && void 0 !== Y ? Y : this.noa.camera.getDirection()
                    , {hitResult: X, hitEId: q, distanceTravelled: u, globalHitPosition: s, hitNormal: e, meshNodeHit: O} = this.pickActionHelper.doPickAction(P, 3 * (window.reach || 1));
                    return X === S.c.HIT_ENTITY ? {
                        pickDir: P,
                        hitEId: q,
                        meshNodeHit: O
                    } : {
                        pickDir: P,
                        hitEId: null,
                        meshNodeHit: null
                    }
                }


AutoClick:

    //  In file where Reach is (or: 2 functions under Reach, or: between breakingStart & upFirePrimary() {, OR (most accurate; above:

                upFirePrimary() {
                return super.upFirePrimary(),

    )) add:

            tick() {
                if (window.autoclick) {
                    const {pickDir: Y, hitEId: P, meshNodeHit: X} = this.tryHitEntity();
                    if (m) {
                        this.doAttack(Y, P, X);
                        this.breakEntity(Y, P);
                    }
                }
                if (this.heldItemState.__id === this.noa.playerEntity) {
                    let Y = !1;
                    return this.breaking && (Y = this.breakBlock()),
                    this.breakingParticles.tick(Y),
                    Y
                }
                return !1
            }
            // To find: pickDir: (), hitEId: (), meshNodeHit: () :  go to 2nd: downFirePrimary() { 

    Raw example:

        before:

            upFirePrimary() {
                return super.upFirePrimary(),
                this.breakingItem.upFirePrimary()
            }

        after:

            tick() {
                if (window.autoclick) {
                    const {pickDir: Y, hitEId: P, meshNodeHit: X} = this.tryHitEntity();
                    if (m) {
                        this.doAttack(Y, P, X);
                        this.breakEntity(Y, P);
                    }
                }
                if (this.heldItemState.__id === this.noa.playerEntity) {
                    let Y = !1;
                    return this.breaking && (Y = this.breakBlock()),
                    this.breakingParticles.tick(Y),
                    Y
                }
                return !1
            }
            //' To find: pickDir: (), hitEId: (), meshNodeHit: () :  go to 2nd: downFirePrimary() { '// 

            upFirePrimary() {
                return super.upFirePrimary(),
                this.breakingItem.upFirePrimary()
            }

Scaffold:

// Find: placeBlock() { (which should be in a "class...extends..."")

// then add:

            tick() {
                if (window.scaffold) {
                    this.placeUnderPlayer()
                }
            }
            //'Scaffold'//

    above placeBlock() {


        raw example:

        before:

            placeBlock() {
                var Y;
                const P = this.noa.targetedBlock;
                let X;
            
            ......

        after:

            tick() {
                if (window.scaffold) {
                    this.placeUnderPlayer()
                }
            }
            //'Scaffold'//
            placeBlock() {
                var Y;
                const P = this.noa.targetedBlock;
                let X;
            
            ......

Infinite Jump:

    find: ".serverSettings.airJumpCount;" and replace that and the var before that with: "window.AirJump;"

    Raw example:

    before:

            const b = (G || X._jumpCount < function(Y, P, X) {
                const q = Y.serverSettings.airJumpCount;
                if (X)
                    return q + 1;
                return q
            }(Y, X.__id, c))

    after:

            const b = (G || X._jumpCount < function(Y, P, X) {
                const q = window.AirJump;
                if (X)
                    return q + 1;
                return q
            }(Y, X.__id, c))

High Jump:

    find: line with: ".jumpMultiplier.getTotalMultipliedVal()".

    Then between ".jumpAmount" and "*" in that line add:
    "+ ((typeof window.JumpAmount === 'number' && !isNaN(window.JumpAmount)) ? window.JumpAmount : 0) "              

    Raw Example:

    Before:

    s.applyImpulse([0, Y.serverSettings.jumpAmount * q.jumpMultiplier.getTotalMultipliedVal(), 0]),

    After:

    s.applyImpulse([0, Y.serverSettings.jumpAmount + ((typeof window.JumpAmount === 'number' && !isNaN(window.JumpAmount)) ? window.JumpAmount : 0) * q.jumpMultiplier.getTotalMultipliedVal(), 0]),


Speed:

    Find: 10th: ".vehicle.tier";
    Then 2 lines under OR under ".jump;" add:

    Object.defineProperty(window, 'GlobalSpeed', {
                get: function () {
                    return this._globalSpeed;
                },
                set: function (value) {
                    this._globalSpeed = value;
                    >>r<<.walkingSpeed = value;
                },
                configurable: true
            });
        
            if (typeof window._globalSpeed === 'undefined') {
                window._globalSpeed = >>r<<.walkingSpeed;
            }
    Note: 1st var is in >><< & you can obtain it from: const {serverSettings: >>r<<} = Y

    //Raw Example:

    //Before:

        const {serverSettings: r} = Y
              , L = u.d[X.vehicle.type]
              , W = q.u[X.vehicle.type].getValues(X.vehicle.tier);
            P.jumping = !!e.jump;
        

        const c = e.forward ? e.backward ? 0 : 1 : e.backward ? -1 : 0
            , S = e.right ? e.left ? 0 : 1 : e.left ? -1 : 0;
            s.e.clientEscMenuOptions.crouchIsToggle ? P.crouching = O.crouchToggled : (e.crouch ? P.crouching = !0 : P.crouching = !1,
            O.crouchToggled = !1);
            const a = L.isMoving ? L.isMoving(S, c, X) : c || S;

    //After:

        const {serverSettings: r} = Y
              , L = u.d[X.vehicle.type]
              , W = q.u[X.vehicle.type].getValues(X.vehicle.tier);
            P.jumping = !!e.jump;
            Object.defineProperty(window, 'GlobalSpeed', {
                get: function () {
                    return this._globalSpeed;
                },
                set: function (value) {
                    this._globalSpeed = value;
                    r.walkingSpeed = value;
                },
                configurable: true
            });
        
            if (typeof window._globalSpeed === 'undefined') {
                window._globalSpeed = r.walkingSpeed;
            }
            const c = e.forward ? e.backward ? 0 : 1 : e.backward ? -1 : 0
              , S = e.right ? e.left ? 0 : 1 : e.left ? -1 : 0;
            s.e.clientEscMenuOptions.crouchIsToggle ? P.crouching = O.crouchToggled : (e.crouch ? P.crouching = !0 : P.crouching = !1,
            O.crouchToggled = !1);
            const a = L.isMoving ? L.isMoving(S, c, X) : c || S;